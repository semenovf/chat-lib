////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2021 Vladislav Trifochkin
//
// This file is part of `chat-lib`.
//
// Changelog:
//      2021.01.02 Initial version.
////////////////////////////////////////////////////////////////////////////////
#include "pfs/chat/persistent_storage/sqlite3/conversation.hpp"
#include "pfs/chat/persistent_storage/sqlite3/transaction.hpp"
#include "pfs/debby/sqlite3/input_record.hpp"
#include "pfs/debby/sqlite3/time_point_traits.hpp"
#include "pfs/debby/sqlite3/uuid_traits.hpp"
#include <array>

namespace chat {
namespace persistent_storage {
namespace sqlite3 {

using namespace debby::sqlite3;

namespace {
    char const * INVALID_CONVERSATION_ERROR = "invalid converstion";

    std::string const DEFAULT_TABLE_NAME_PREFIX { "#" };

    std::string const OPEN_CONVERSATION_ERROR { "open converstion table failure: {}: {}" };
    std::string const CREATE_MESSAGE_ERROR    { "create message failure: {}" };
    std::string const WIPE_ERROR              { "wipe converstion failure: {}: {}" };
    std::string const WIPE_ALL_ERROR          { "wipe all converstions failure: {}" };
}

namespace {

std::string const CREATE_CONVERSATION_TABLE {
    "CREATE TABLE IF NOT EXISTS `{}` ("
    "`message_id` {} NOT NULL UNIQUE"   // Unique message id (generated by author)
    ", `author_id` {} NOT NULL"         // Author contact ID
    ", `creation_time` {} NOT NULL"     // Creation time (UTC)
    ", `modification_time` {} NOT NULL" // Modification time (UTC)
    ", `dispatched_time` {}"            // Dispatched (for outgoing) time (UTC)
    ", `delivered_time` {}"             // Delivered time (for outgoing) or received (for incoming) (UTC)
    ", `read_time` {}"                  // Read time (for outgoing and incoming) (UTC)
    ", `content` {})"                   // Message content
};

} // namespace

conversation::conversation (contact::contact_id my_id
    , contact::contact_id addressee_id
    , database_handle_t dbh
    , error * perr)
    : base_class()
    , _my_id(my_id)
    , _addressee_id(addressee_id)
    , _dbh(dbh)
{
    _table_name = DEFAULT_TABLE_NAME_PREFIX + to_string(_addressee_id);

    std::array<std::string, 1> sqls = {
        fmt::format(CREATE_CONVERSATION_TABLE
            , _table_name
            , affinity_traits<decltype(message::message_credentials{}.id)>::name()
            , affinity_traits<decltype(message::message_credentials{}.author_id)>::name()
            , affinity_traits<decltype(message::message_credentials{}.creation_time)>::name()
            , affinity_traits<decltype(message::message_credentials{}.modification_time)>::name()
            , affinity_traits<decltype(message::message_credentials{}.dispatched_time)>::name()
            , affinity_traits<decltype(message::message_credentials{}.delivered_time)>::name()
            , affinity_traits<decltype(message::message_credentials{}.read_time)>::name()
            , affinity_traits<std::string>::name())
    };

    error err;

    process_transaction(_dbh, sqls.begin(), sqls.end()
        , [this] (std::string const & sql, debby::error * storage_err) {
            return _dbh->query(sql, storage_err);
        }
        , [this, & err] (debby::error * storage_err) {
            err = {errc::storage_error
                , fmt::format(OPEN_CONVERSATION_ERROR
                    , to_string(_addressee_id), storage_err->what())
            };

            database_handle_t empty;
            _dbh.swap(empty);
        });

    if (err) {
        if (perr) *perr = err;
        else CHAT__THROW(err);
    }
}

bool conversation::wipe_impl (error * perr)
{
    PFS__ASSERT(*this, INVALID_CONVERSATION_ERROR);

    debby::error storage_err;

    if (!_dbh->remove(_table_name, & storage_err)) {
        error err {errc::storage_error, fmt::format(WIPE_ERROR
                , to_string(_addressee_id), storage_err.what())};
        if (perr) *perr = err; else CHAT__THROW(err);
        return false;
    }

    return true;
}

bool conversation::wipe_all (database_handle_t dbh, error * perr)
{
    PFS__ASSERT(dbh, "");

    debby::error storage_err;
    auto tables = dbh->tables("^" + DEFAULT_TABLE_NAME_PREFIX, & storage_err);

    auto success = !storage_err;

    if (success) {
        if (tables.empty())
            return true;

        success = dbh->remove(tables, & storage_err);
    }

    if (!success) {
        error err {errc::storage_error, fmt::format(WIPE_ALL_ERROR, storage_err.what())};
        if (perr) *perr = err; else CHAT__THROW(err);
    }

    return success;
}

namespace {
std::string const INSERT_MESSAGE {
    "INSERT INTO `{}` (`message_id`, `author_id`, `creation_time`, `modification_time`)"
    " VALUES (:id, :author_id, :creation_time, :modification_time)"
};
} // namespace

editor conversation::create_impl (error * perr)
{
    PFS__ASSERT(*this, INVALID_CONVERSATION_ERROR);

    auto message_id = message::id_generator{}.next();
    auto creation_time = pfs::current_utc_time_point();

    debby::error storage_err;
    auto stmt = _dbh->prepare(fmt::format(INSERT_MESSAGE, _table_name), true, & storage_err);
    bool success = !!stmt;

    success = success
        && stmt.bind(":id", to_storage(message_id), false, & storage_err)
        && stmt.bind(":author_id", to_storage(_my_id), false, & storage_err)
        && stmt.bind(":creation_time", to_storage(creation_time), & storage_err)
        && stmt.bind(":modification_time", to_storage(creation_time), & storage_err);

    if (success) {
        auto res = stmt.exec(& storage_err);

        if (res.is_error()) {
            success = false;
        }
    }

    if (!success) {
        error err {errc::storage_error, fmt::format(CREATE_MESSAGE_ERROR, storage_err.what())};
        if (perr) *perr = err; else CHAT__THROW(err);
    } else {
        PFS__ASSERT(stmt.rows_affected() > 0, "Non-unique ID generated for message");
    }

    return success ? editor{message_id, _dbh, _table_name} : editor{};
}

namespace {

std::string const SELECT_OUTGOING_CONTENT {
    "SELECT `message_id`"
        ", `content`"
        " FROM `{}` WHERE `message_id` = :message_id AND `author_id` = :author_id"
};              //                                                    ^
                //                                                    |
                // Interest is shown only to the outgouing message ----

} // namespace

editor conversation::open_impl (message::message_id message_id, error * perr)
{
    PFS__ASSERT(*this, INVALID_CONVERSATION_ERROR);

    debby::error storage_err;
    auto stmt = _dbh->prepare(fmt::format(SELECT_OUTGOING_CONTENT, _table_name)
        , true, & storage_err);
    bool success = !!stmt;

    success = success
        && stmt.bind(":message_id", to_storage(message_id), false, & storage_err)
        && stmt.bind(":author_id", to_storage(_my_id), false, & storage_err);

    if (success) {
        auto res = stmt.exec(& storage_err);

        if (res.has_more()) {
            input_record in {res};
            message::message_id message_id;
            contact::contact_id my_id;
            std::string content_data;

            success = in["message_id"] >> message_id
                && in["content"]       >> content_data;

            if (success) {
                error err;
                message::content content{content_data, & err};

                if (!content) {
                    if (perr) *perr = err; else CHAT__THROW(err);
                    return editor{};
                }

                return editor{message_id, std::move(content), _dbh, _table_name};
            }
        }

        if (res.is_error())
            success = false;
    }

    if (!success) {
        auto err = error{errc::storage_error
            , fmt::format("fetch outgoing message failure: #{}", to_string(message_id))
            , storage_err.what()};
        if (perr) *perr = err; else CHAT__THROW(err);
    }

    return editor{};
}

auto conversation::count_impl () const -> std::size_t
{
    PFS__ASSERT(*this, INVALID_CONVERSATION_ERROR);
    return _dbh->rows_count(_table_name);
}

auto conversation::unread_messages_count_impl () const -> std::size_t
{
    PFS__ASSERT(*this, INVALID_CONVERSATION_ERROR);
    // TODO
    return 0;
}

}}} // namespace chat::persistent_storage::sqlite3

