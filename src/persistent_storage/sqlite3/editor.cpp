////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2021 Vladislav Trifochkin
//
// This file is part of `chat-lib`.
//
// Changelog:
//      2021.01.04 Initial version.
////////////////////////////////////////////////////////////////////////////////
#include "pfs/bits/compiler.h"
#include "pfs/chat/persistent_storage/sqlite3/editor.hpp"

#if PFS_COMPILER_MSVC
#   include <io.h>
#   include <fcntl.h>
#   include <share.h>
#endif // PFS_COMPILER_MSVC

#if PFS_COMPILER_GCC
#   include <sys/types.h>
#   include <sys/stat.h>
#   include <fcntl.h>
#   include <string.h>
#endif // PFS_COMPILER_GCC

namespace chat {
namespace persistent_storage {
namespace sqlite3 {

// using namespace debby::sqlite3;
namespace fs = pfs::filesystem;

namespace {
//     std::string const DEFAULT_TABLE_NAME_PREFIX { "#" };
//
//     std::string const OPEN_CONVERSATION_ERROR { "open converstion table failure: {}: {}" };
//     std::string const CREATE_MESSAGE_ERROR    { "create message failure: {}" };
//     std::string const WIPE_ERROR              { "wipe converstion failure: {}: {}" };
//     std::string const WIPE_ALL_ERROR          { "wipe all converstions failure: {}" };
}

namespace {

// std::string const CREATE_CONVERSATION_TABLE {
//     "CREATE TABLE IF NOT EXISTS `{}` ("
//     "`message_id` {} NOT NULL UNIQUE"   // Unique message id (generated by author)
//     ", `contact_id` {} NOT NULL"        // Author (for outgoing) or addressee (for incoming) contact ID
//     ", `creation_time` {} NOT NULL"     // Creation (for outgoing) time (UTC)
//     ", `dispatched_time` {}"            // Dispatched (for outgoing) time (UTC)
//     ", `dlvrcv_time` {}"                // Delivered time (for outgoing) or received (for incoming) (UTC)
//     ", `read_time` {}"                  // Read time (for outgoing and incoming) (UTC)
//     ", `content` {})"                   // Message content
// };

} // namespace

editor::editor (message::outgoing_credentials && m)
    : base_class()
    , _m(std::move(m))
{}

auto editor::add_text_impl (std::string const & text) -> bool
{
    _content += text;
    return true;
}

auto editor::add_emoji_impl (std::string const & shortcode, error * perr) -> bool
{
    if (!emoji_db::has(shortcode)) {
        auto err = error{errc::bad_emoji_shortcode, shortcode};
        if (perr) *perr = err; else CHAT__THROW(err);
        return false;
    }

    _content += "<emoji>" + shortcode + "</emoji>";

    return true;
}

auto editor::attach_impl (fs::path const & path, error * perr) -> bool
{
    auto utf8_path = fs::utf8_encode(path);

    if (!fs::exists(path)) {
        auto err = error{errc::access_attachment_failure
            , utf8_path
            , "file not found"};
        if (perr) *perr = err; else CHAT__THROW(err);
        return false;
    }

    if (!fs::is_regular_file(path)) {
        auto err = error{errc::access_attachment_failure
            , utf8_path
            , "attachment must be a regular file"};
        if (perr) *perr = err; else CHAT__THROW(err);
        return false;
    }

#if PFS_COMPILER_MSVC
    int fd = -1;
    errno_t errn = _wsopen_s(& fd
        , path.c_str()
        , _O_RDONLY | _O_BINARY // oflag
        , _SH_DENYWR            // shflag
        , 0);                   // pmode

    if (errn != 0) {
        auto err = error{errc::access_attachment_failure
            , utf8_path
            , strerror(errn)};
        if (perr) *perr = err; else CHAT__THROW(err);
        return false;
    }
#elif PFS_COMPILER_GCC
    int fd = ::open(utf8_path.c_str(), O_RDONLY);

    if (fd < 0) {
        auto err = error{errc::access_attachment_failure
            , utf8_path
            , strerror(errno)};
        if (perr) *perr = err; else CHAT__THROW(err);
        return false;
    }
#endif

    return true;
}

}}} // namespace chat::persistent_storage::sqlite3
